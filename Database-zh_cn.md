- 数据：描述现实世界中事物的可以识别的符号

- 信息：被加工为特定形式的数据

- 数据处理：从大量原始数据中抽取和推导出有价值信息的加工过程

- 数据库系统：建立在DBMS之上，以满足实际应用需求的数据管理为主要功能的计算机软件系统

- 数据库系统的组成：
  - 数据库：数据库系统中存储的数据集合
  - 用户：终端用户、应用程序员、数据库管理员
  - 软件：DBMS等
  - 硬件：存储数据库和运行软件的硬件资源
  
- 数据库系统的特征
  - 面向全组织的数据结构化
  - 数据集成与共享，冗余度可控
  - 数据独立性：
    - 物理独立性：数据存储结构改变时，逻辑结构可不变
    - 逻辑独立性：数据逻辑结构改变时，应用程序可不变
  - 统一的数据控制机制
    - 安全性控制
    - 完整性控制
    - 并发控制
    - 数据库恢复
  
- 数据库系统的模式
  - 外模式：用户的数据视图
  - 模式：所有用户的公共数据视图
  - 内模式（存储模式）：数据的物理结构和存储方式
  
- 模型分为两个层次
  - 概念模型：从用户的观点建立的模型，包括E-R图等
  - 数据模型：从计算机实现的观点建立的模型，包括层次、网状、关系模型
  
- 数据模型：现实世界数据特征的抽象

- 数据模型要求：
  - 能比较真实地模拟现实世界
  - 容易理解
  - 便于在计算机上实现

- 数据模型三要素：
  - 数据结构：描述静态特性，包括对象、对象之间的联系
  - 数据操作：描述动态特性，包括操作和操作规则
  - 完整性约束：完整性规则的集合

- 数据模型类别：
  - 层次模型：使用树表示数据之间的联系
  - 网状模型：使用图表示数据之间的联系
  - 关系模型：使用二维表表示数据之间的联系

- 模型的主要概念
  - 实体：客观存在且可以相互区分的事物
  - 属性：实体的某一种特性
  - 域：属性的取值范围
  - 实体型：具有相同属性的实体拥有的共同的特征和性质
  - 实体集：所有同类型实体的集合
  - 码：能唯一标识实体的属性集
  - 联系：实体的属性之间或实体集之间的联系
    - 联系包括一对一、一对多和多对多

- 关系数据模型组成部分
  - 数据结构：关系，即二维表
    - 域：一组具有相同数据类型的值的集合
    - 关系的性质：
      - 列是同质的，即每一列的分量来自同一个域
      - 不同的列可出自同一个域，但所有列必须拥有不同属性名
      - 列的顺序可以互换
      - 行的顺序可以互换
      - 任意两个元组不能完全相同
      - 每个分量是不可再分的数据
    - 关系模式：关系的描述，包括属性名、属性集所在的域、属性向域的映射、属性之间的数据依赖关系和完整性约束
      - 一般简记为R(A1,...,An)，其中R是关系名，Ai是属性名
    - 候选码：对于关系模式R(U)的属性集合k，若R(U)的任意关系的任意两个元组在k上的值都不同，且k的任意真子集不满足该条件，则称k是候选码
      - 候选码是唯一标识所有元组的极小属性集合
    - 主码：当一个关系具有多个候选码时，人为指定其中一个作为主码
    - 主属性：包含在其中一个候选码的属性称为主属性，否则称为非主属性
    - 全码：若候选码包括所有属性，则称为全码
    - 外码：若F是R的一个或一组属性，但不是R的码，且F与关系S的主码对应，则称F是R的外码，且称R是参照关系，S是被参照关系；R和S可以相同
  - 关系操作：选择、投影等，操作的对象和结果都是集合
    - 并：若R和S是n元关系，且对应属性的数据类型相同，则R∪S由属于R或属于S的元组构成
    - 差：若R和S是n元关系，且对应属性的数据类型相同，则R-S由属于R但不属于S的元组构成
    - 交：若R和S是n元关系，且对应属性的数据类型相同，则R∩S由既属于R又属于S的元组构成
    - 广义笛卡尔积：若两个关系R和S，度分别为n和m，则广义笛卡尔积R×S表示R的每个元组拼接S的每个元组的共n×m个元素的集合
    - 选择：在关系R中选择满足给定条件的元组，记作σ$\rm_F$(R)
    - 投影：在关系R中选择指定的列，并**删除重复行**，记作$\rm \Pi_{X}(R)$
    - 连接：从R和S的广义笛卡尔积中选择满足给定条件的元组，记作$R\underset{A\theta B}{\mathop{\bowtie}}S$
      - 自然连接：从笛卡尔积中选择相同属性列取值相同的元组，且**去掉重复列**
        - 自然连接和等值连接的区别，在于等值连接将会同时保留两侧的列，自然连接则是仅保留1列
      - 复合连接：运算结果不包含连接的属性的自然连接
      - 半连接：仅保留一侧匹配结果的连接
      - 外连接：在自然连接中加入未匹配结果的连接，其中未匹配的结果中另一个关系的属性值都设为空值
    - 除法：对于关系R，选出和S中所有元组的连接结果都在R中的去掉S的属性的元组
  - 关系数据语言
    - 关系代数
    - 元组关系演算
      - 元组关系演算中，每个关系作为一个谓词
        - 例如R(t)表示元组t属于关系R
      - 用元组的元素表示对应的关系中元组的元素
        - 例如t[2]表示元组t的第2个属性的元素
      - 使用t$\rm^{(n)}$表示长度为n的元组
        - 例如{t$\rm^{(2)}$|$\exists$u$\exists$v(R(u)$\and$S(v)$\and$u[1]=v[1]$\and$t[1]=u[2]$\and$t[2]=v[3])}表示R.1=S.1条件下取R的第二个属性和S的第三个属性
    - SQL
  
- SQL
  - Select
  - Insert
    - 插入值：Insert Into 表(列) Values(值);
    - 插入子查询：Insert Into 表(列) 子查询;
  - Update
    - Update 表 Set 列=表达式 Where 条件;
  - Delete
    - Delete From 表 Where 条件;
  - Create
    - 新建表：Create Table 表(列 数据类型 列完整性约束, 表完整性约束)
      - Create Table Student(id Int Primary Key, name Char(5) Default 'NAME', Check(id > 0))
    - 新建视图：Create View 视图 [(列)] As 子查询 [With Check Option]
      - 视图更新约束：子查询不包括①聚集函数②Group By子句③Distinct关键字④经过算术表达式计算的列
    - 新建索引：Create \[Unique]\[Cluster] Index 索引 On 表 (列 [ASC|DESC] [,...])
  - Alter
    - Alter Table 表 Add(列 数据类型 完整性约束)
    - Alter Table 表 Drop 完整性约束名称
    - Alter Table 表 Modify 列 数据类型
  - Drop
    - Drop Table 表
    - Drop View 视图
  - Grant/Revoke
    - 用户级权限
      - Grant 权限|角色 To 用户|角色|Public [With Grant Option]
      - Revoke 权限|角色 From 用户|角色|Public
    - 关系级权限
      - Grant All|权限 On 表|视图 To 用户|Public [With Grant Option]
      - Revoke All|权限 On 表|视图 From 用户|Public
  - 相关子查询与不相关子查询
    - 相关子查询引用了外部查询的属性，对于外部查询的每一行，相关子查询都要执行一次
    - 不相关子查询不引用外部查询的属性，只需要执行一次
  
- 安全性：防止不合法的使用造成的数据泄露、更改和破坏

  - 安全性保障方法
    - 用户标识与鉴别：采用一定方式标识用户或应用程序的身份，并在登录时判断身份是否合法
    - 存取控制：确保用户按照指定的权限访问数据
    - 审计功能：记录用户对数据库的操作并写入审计日志
    - 数据加密：将数据变换为不可识别的密文
  - 存取控制：包括定义用户权限、合法权限检查
    - 自主存取控制：
      用户对于不同数据对象拥有不同存取权限；
      不同用户对同一数据对象拥有不同存取权限；
      用户可将拥有的权限授权给其他用户
    - 强制存取控制：
      每个数据对象被标注为一定的密级；
      每个用户被授予一定级别的许可证；
      仅当主体的许可证级别**大于等于**客体的密级时，主体可读客体
      仅当主体的许可证级别**等于**客体的密级时，主体可写客体
  - 数据库系统中可授予用户两类权限
    - 用户级权限：管理员为每个用户授予的特定权限，用户级权限是对使用整个数据库的权限的限制
    - 关系级权限：管理员或对象的拥有者为用户授予的关于特定关系或视图的权限

- 完整性：数据的正确性和相容性
  - 正确性：数据应具有合法的类型，且在有效取值范围内
  - 相容性：表示同一个事实的两个数据应该相同
  - 完整性约束：施加在数据库的数据上的语义约束条件
    完整性约束条件作用的对象可以是关系、元组或列（如char(10)）
    - 数据库完整性控制功能
      - 定义功能：定义完整性约束
      - 检查功能：检查用户的操作请求是否符合完整性约束
      - 违约响应：若违背完整性约束，采取措施保证数据完整性
    - 按照条件类型
      - 实体完整性约束：主码的任意属性不得取空值，在insert和update的时候检查
      - 参照完整性约束：若R1的外码F与R2的主码P相对应，则F的值要么等于某个P的值，要么为空值，在insert、update和delete的时候检查
      - 用户定义完整性约束：由用户定义的约束
    - 按照作用时间
      - 静态约束：数据库在每一确定状态时满足的约束
        - 固有约束：数据模型本身具有的约束，例如关系的属性不可再分
        - 隐含约束：隐含在数据模式的约束，如实体完整性约束
        - 显式约束：依赖于数据的语义和应用，需要显式定义的完整性约束
      - 动态约束：数据库从一种状态转变为另一种状态时，旧值和新值之间满足的约束

- 函数依赖

  - 若对于关系模式R(U)的任意关系，不存在两个元组，在属性集X上取值相同，但在Y上取值不同，则称Y函数依赖X，记作X→Y
  - 部分函数依赖：若对于任意X的真子集X'，都不满足X'→Y，则称Y完全函数依赖X，否则称部分函数依赖X
  - 传递函数依赖：若Y不是X的子集，Z不是Y的子集，X→Y、Y→Z且没有Y→X，则称Z传递依赖X
  - 多值依赖：若对于关系模式R(U)的任意关系r，在r中存在元组(x,z,y1)，...，(x,z,yn)，其中x是属性集X的取值，{y1,...,yn}是属性集Y的取值并构成一个集合y'，y'仅和x的取值有关，而无论z取什么值y'都不变，则称Y多值依赖X，记作X→→Y
    - 多值依赖和属性集的全集有关，若在全集上成立，在全集的子集上也成立；在全集的子集上成立，在全集上不一定成立
    - 函数依赖是特殊的多值依赖，但函数依赖与全集的范围无关
    - 平凡多值依赖：X→→U-X和X→→∅总是成立

- 范式

  - 1NF：关系的每个分量不可再分
  - 2NF：在1NF基础上，不存在非主属性对码的部分函数依赖
  - 3NF：在1NF基础上，不存在非主属性对码的部分函数依赖和传递函数依赖
  - BCNF：在1NF基础上，若X→Y，且Y不是X的子集，则X一定含有码
    即：不存在**任何属性**对不包含该属性的码的部分函数依赖和传递函数依赖
  - 4NF：在1NF基础上，若非平凡多值依赖X→→Y，且Y不是X的子集，则X一定含有码
    即：不存在除平凡多值依赖和函数依赖之外的多值依赖

- 数据依赖的公理系统（记关系模式R(U)的函数依赖集合为F）

  - Armstrong公理

    - 自反律：若Y⊆X，则X→Y
    - 增广律：若X→Y，则XZ→YZ
    - 传递律：若X→Y，Y→Z，则X→Z

  - 闭包：F逻辑蕴涵（F中的函数依赖可以推导出）的所有函数依赖的集合称为F的闭包，记作F$\rm^+$

    - 有效性：从F的函数依赖根据公理推出的函数依赖一定在F$\rm^+$中
    - 完备性：F$\rm^+$的每个函数依赖都能从F的函数依赖根据公理推出
    - 等价：若F$\rm^+$=G$\rm^+$，称F和G等价

  - 最小函数依赖集（最小覆盖）：

    - 对于F中所有函数依赖X→A，A仅有一个属性
    - 对于F中所有函数依赖X→A，F和F-{X→A}不等价
    - 对于F中所有函数依赖X→A和X的真子集Z，F和(F-{X→A})∪{Z→A}不等价，即不能将X替换为X的任一个真子集

  - 属性集的闭包：对于属性集X，F$\rm^+$中所有形如X→A的依赖中单个属性A的集合称为X关于函数依赖集F的闭包，记作X$\rm_F^+$

    - X→Y$\Leftrightarrow$Y⊆X$\rm_F^+$

  - 定理

    - 合并律：若X→Y，X→Z，则X→YZ
    - 分解律：若X→YZ，则X→Y，X→Z
    - 伪传递律：若X→Y，WY→Z，则XW→Z

  - 关系模式分解

    - 对于一个属性集V，函数依赖集合G={X→Y|X→Y∈F$\rm^+$$\and$XY⊆V}，即F的闭包中所有仅包含V中的属性的部分，称为F在V上的投影
    - 若U1,U2,...,Un满足U=$\bigcup_{i=1}^n\rm Ui$，且不存在某个Ui⊆Uj，记Fi为F在Ui上的投影，则称ρ={R1<U1,F1>,...,Rn<Un,Fn>}为关系模式R的一个分解
      - 对于R的一个关系r，记m$\rm_\rho$(r)=$\bowtie$Π$\rm_{Ri}$(r)，即r在ρ之中各关系模式投影上的自然连接
    - 无损连接分解：若关系模式分解ρ对于任意的关系r，都满足r=m$\rm_\rho$(r)，称ρ是无损连接分解
      - 特别地，若ρ仅有两个关系模式，且U1∩U2→U1，则ρ是无损连接分解

  - 算法

    - 求属性集X的闭包：

      - 将集合X$\rm^+$初始化为X
      - 对于X$\rm^+$中的所有属性集合V，求所有V→W∈F，将W的属性加入X$\rm^+$
      - 若X$\rm^+$在一次迭代中没有更新，则结束

    - 求F的最小函数依赖集：

      - 对于F中所有函数依赖X→A1A2...An，用X→A1、X→A2、...、X→An代替
      - 检查F的每个函数依赖X→A
        - 若F-{X→A}可推出X→A，则从F中去掉X→A
        - 若X=B1B2...Bm，且A属于(X-Bi)$\rm_F^+$，即A直接或传递函数依赖X-Bi，则使用X-Bi→A替换X→A

    - 求关系模式R<U, F>的候选码：

      - 对于F中所有函数依赖X→A，统计所有出现在左侧的属性集合A={A1, A2, ..., Am}和出现在右侧的属性集合B={B1, B2, ..., Bn}
        - 候选码一定包含(U-(A∪B))∪(A-B)的所有属性，即从未在F中出现过的属性和仅在左侧出现的属性
        - 候选码一定不包含B-A中的属性，即仅在右侧出现的属性
      - 将A-B加入队列
      - 从队列中取出一个集合X，计算X$\rm_{F}^+$
        - 若X$\rm_{F}^+$=A∪B，则(U-(A∪B))∪X是候选码
        - 否则，记A∪B-X$\rm_{F}^+$=Y1Y2...Yk，将X∪{Y1}, ..., X∪{Yk}加入队列
        - 重复操作，直到队列为空

    - 判断关系模式分解ρ是否是无损连接分解

      - 将函数依赖集F变为最小函数依赖集

      - 建立一个k行n列的矩阵，其中k为关系模式的个数，n为属性的个数

        - 若属性Aj属于Ui，则在i行j列填入a$\rm_j$，否则填入b$\rm_{ij}$

      - 对于每个X→A，找到X对应的若干列中具有相同符号的行

        - 对于选择的**若干行**和**A所在列**的子表，若列中有a$\rm_j$，则将该列中的符号**在整个表范围内**全部改为a$\rm_j$，否则将该列全部改为$\rm b_{mj}$，其中m是行号的最小值；特别地，若某个b$\rm_{ij}$被修改，则该列的所有b$\rm_{ij}$全部都要被修改

          例如A2→A3

          |      | A1   | A2      | A3    | A4   |
          | ---- | ---- | ------- | ----- | ---- |
          | U1   | a1   | **b12** | *b13* | a4   |
          | U2   | b21  | **b12** | *a3*  | a4   |
          | U3   | a1   | b32     | *b13* | b34  |
          | U4   | b41  | a2      | a3    | b44  |

          该表应改为：

          |      | A1   | A2      | A3   | A4   |
          | ---- | ---- | ------- | ---- | ---- |
          | U1   | a1   | **b12** | *a3* | a4   |
          | U2   | b21  | **b12** | *a3* | a4   |
          | U3   | a1   | b32     | *a3* | b34  |
          | U4   | b41  | a2      | a3   | b44  |

      - 若在某一步之后，表的一行变为a$\rm_1$a$\rm_2$...a$\rm_n$，则说明该分解是无损分解；否则是有损分解
      
    - 保持函数依赖且达到3NF的分解算法

      - 将函数依赖集F变为最小函数依赖集，将ρ初始化为∅
      - 对于不在F中出现的属性，使用这些属性作为一个关系模式R'<U',∅>加入ρ，从U中去掉U'
      - 若X→A∈F，且XA=U，则将R加入ρ，得到结果；
        否则，将拥有相同左侧Xi的函数依赖分为同一组，分别统计每组涉及的全部属性Ui，若存在Ui⊆Uj则去掉Ui，将{R1(U1),...,Rk(Uk)}加入ρ，得到结果
        - 例如{AB→C, AB→D, D→B, C→E}，得到的集合为ABCD、BD、CE，去掉BD，得到R1(ABCD)和R2(CE)两个子模式
      - 若还需要保证无损连接分解，对于R(U)的码X，若存在X⊆Ui，则该分解直接是无损连接分解；否则将R\*(X)加入ρ，得到无损连接分解

    - 达到BCNF且保证无损连接的分解算法

      - 将ρ初始化为{R(U)}
      - 若存在不是BCNF的Ri(Ui)∈ρ，则找到X→A∈F$\rm_i^+$，且X不是Ri的码，将Ri(Ui)分解为S1(XA)和S2(Ui-{A})
      - 该算法不能保证保持函数依赖

- 数据库设计：对于一个应用领域，构造一个最优的数据库模式
  - 要反映信息、信息之间的联系
  - 要反映使用者对数据的需求和操作特点
  - 要便于在DBMS中实现
  
- 数据库规范化设计方法
  - 需求分析
  - 概念结构设计
    - 设计策略
      - 自顶向下：先定义全局概念结构的框架，再逐步细化
      - 自底向上：先定义局部的概念结构，再集成起来
      - 逐步扩张：先定义最核心的概念结构，再向外扩充，逐步生成其他概念结构
      - 混合策略：用自顶向下策略设计一个全局概念结构框架，用该全局框架集成自底向上策略的局部概念结构
    - 视图综合设计方法
      - 设计局部概念结构：确定局部实体与实体间联系，构造局部E-R图
      - 将局部概念结构合并为全局概念结构：合并局部E-R图
      - 视图集成两个方法：直接一次集成多个局部E-R图，或一次集成两个分E-R图，逐步集成所有视图
      - 视图集成步骤：合并；修改和重构
        - 合并：解决局部E-R图的冲突，合并成初步E-R图
        - 修改和重构：消除冗余，生成基本E-R图
      - 局部E-R图的冲突
        - 命名冲突：同名异义、异名同义
        - 结构冲突：相同的概念使用不同的结构表示，包括在一个E-R图中是实体的概念在另一个图中是属性，或同一实体在不同E-R图中的属性不同
        - 值域冲突：相同的属性在不同的E-R图中类型、取值范围或单位不同
        - 约束冲突：在两个局部E-R图上具有不同的约束
    - E-R图
      - 属性：属性不可再分，不能再包含属性，一个属性只能与一个实体有联系
    - 事务设计：定义事务的输入、输出和功能
  - 逻辑结构设计
    - 目标
      - 满足完整性和安全性要求
      - 动态关系满足3NF、静态关系满足1NF
      - 在逻辑上高效支持事务的运行
      - 空间利用率高
    - 步骤
      - 形成初始关系数据库模式
      - 关系模式规范化
      - 关系模式优化
        - 水平分解：将关系的元组分成多个子集
        - 垂直分解：将关系的属性分成多个子集
        - 逆规范化：将经常需要连接的关系合并为一个关系
      - 定义完整性和安全性约束
      - 定义子模式
      - 性能估计
  - 物理结构设计
    - 存取方法
      - （B+树）索引存取方法
      - hash存取方法
      - 聚簇存取方法：将某个属性的值相同的数据存储于连续的物理块
    - 文件组织：记录在单个文件中的组织方式
      - 堆组织方式：记录可放在文件中的任何有空间的地方
      - 顺序组织方式：记录基于码的值按顺序存储
      - 散列组织方式：记录按照某属性的散列函数值存储
      - 聚簇组织方式：可将多个关系存储在同一个文件，将属性的值相同的数据放在一起
    - 索引：基本索引有有序索引和散列索引两种
      - 有序索引：索引项按照搜索码值顺序有序存储
        - 主索引（聚簇索引）：索引顺序和记录顺序相同，一般主索引的搜索码是主码
        - 辅助索引（非聚簇索引）：索引顺序和记录顺序不同
        - 稠密索引：对文件的每个搜索码值都有一条索引记录，稠密索引的数据可以不按照索引顺序存放
          - 辅助索引必须是稠密索引
        - 稀疏索引：只对一些搜索码值有索引，稀疏索引只能用于文件按照搜索码值排序的情况
        - 多级索引：若主索引不能一次放入内存，可对主索引再建立一层稀疏索引，以此类推
      - 散列索引：一个桶是一个单元，根据搜索码的散列函数值直接得到搜索码所在的桶位置
      - 多属性索引：在多个属性上建立索引
        - 位图索引：一种特殊的索引，一般用于高效多键查询
    - 数据字典：保存元数据，包括
      - 关系的信息：关系名、关系的属性名、视图定义、完整性约束等
      - 用户和账号信息
      - 统计与描述数据
      - 物理文件组织信息：包括关系的存储方法和物理位置
      - 索引信息
      - 目录结构
  - 数据库实施
  - 数据库运行和维护
  
- 查询优化
  - 数据库性能的组成因素：正确性、可用性、响应时间
  - 连接操作类别
    - 嵌套循环连接
    - 排序-合并连接
    - 索引连接
    - hash连接
  - 查询优化的一般准则
    - 选择运算尽可能先做
      - 选择运算可减小关系的大小
    - 在连接操作前对文件预处理
      - 包括进行排序、在连接的属性上建立索引
    - 投影和选择运算同时做，将投影和前面或后面的双目运算结合起来
      - 同时做多个运算可减少关系的扫描次数

- 事务：不可分割的数据库操作单位

  - 事务的特性
    - 原子性：事务的操作要么全做，要么全不做
    - 一致性：事务应使数据库从一个一致性状态转变为另一个一致性状态
    - 隔离性：事务的执行不能被其他事务干扰
    - 持久性：事务提交后对数据库产生永久影响

  - 故障的种类
    - 事务内部故障
    - 系统故障
    - 介质故障
    - 计算机病毒
  - 数据库恢复的原理：冗余
    - 建立冗余的方法：数据转储
      - 静态转储：系统在没有事务运行时进行转储
      - 动态转储：转储期间允许对数据库进行操作，即转储和事务可并发进行
    - 转储的方法：
      - 海量转储：每次转储整个数据库
      - 增量转储：每次只转储上一次转储后更新的数据
    - 日志文件：记录事务对数据库的更新操作的文件，可用于事务故障恢复和系统故障恢复
      - 以记录为单位的日志文件：包括每个事务的开始标记、结束标记和所有更新操作
      - 以数据块为单位的日志文件：包括事务标识、更新前和更新后的数据块
      - 动态转储必须建立日志文件，后备副本和日志文件综合起来才能保证备份的一致性
      - 静态转储也可以建立日志文件
    - 登记日志文件：登记次序严格按照并发事务的执行顺序；必须先写日志文件再写数据库
    - 事务故障恢复：撤销运行到终点前被终止的事务的更新操作
      - 反向扫描日志，对事务的更新操作执行逆操作，直到发现事务的开始标志
    - 系统故障恢复：重做更新未写入数据库的事务、撤销未完成的事务
      - 正向扫描日志，找到已提交的事务放入重做队列，找到未完成的事务放入撤销队列
      - 对撤销队列的每个事务进行撤销，即反向扫描日志
      - 对重做队列的每个事务进行重做，即正向扫描日志
    - 介质故障恢复：恢复被部分或全部破坏的数据库和日志文件
      - 装入最新的后备副本，对于动态转储的副本还需要装入转储开始时的日志副本并恢复
      - 装入转储后的日志副本并重做已完成的事务
    - 事务更新方式
      - 推迟更新技术：每个事务到达提交点前不能更新数据库；更新操作的日志写入存储器之前事务不能到达提交点
      - 即时更新技术：日志写入存储器之前不允许更新数据库；所有日志都写入之前不允许事务提交
    - 检查点技术：日志文件中的一种记录，包括建立检查点时正在执行的事务清单、正在执行的事务最近的一个日志记录的位置，使用“重新开始文件”记录每个检查点在日志文件的位置
      - 检查点用于标记已完成的事务，在检查点之前写入的事务一定已经完成

- 并发执行事务

  - 并发执行的问题
    - 丢失修改：两个事务读入同一数据，后执行的事务提交的结果破坏了先执行的事务提交的结果，导致先提交的事务修改被丢失
    - 脏读：读取到的已经修改的数据被撤销修改
    - 不可重复读：一个事务在另一个事务修改前和修改后分别读入同一数据，导致两次读取的值或行数不同
  - 并发控制方法：在事务对某个数据对象进行操作前，先向系统发出请求，系统对数据对象加锁，限制其他事务对该对象的操作
    - 排它锁（X锁）：若事务对数据对象加上排它锁，则不允许其他事务对该对象执行任何封锁请求
    - 共享锁（S锁）：若事务对数据对象加上共享锁，则不允许其他事务对该对象加排它锁，只允许加共享锁
  - 封锁协议
    - 一级封锁协议：事务修改数据前必须加X锁，事务结束才能释放
      - 一级封锁协议可防止丢失修改
    - 二级封锁协议：在一级封锁协议基础上，事务在读取数据前必须加S锁，读取完后即可释放
      - 二级封锁协议可防止丢失修改、脏读
    - 三级封锁协议：在一级封锁协议基础上，事务在读取数据前必须加S锁，事务结束才能释放
      - 二级封锁协议可防止丢失修改、脏读、不可重复读
  - 死锁：若存在一系列事务，前一个事务等待后一个事务解锁，形成一个闭环，则称为死锁
    - 死锁预防
      - 一次封锁法：每个事务必须一次将所有需要的锁全部加锁，否则不能执行
      - 顺序封锁法：对数据对象预先规定封锁顺序，必须按照顺序加锁
    - 死锁检测
      - 超时法：一个事务等待时间超过期限则认为死锁
      - 等待图法：对事务的等待情况做有向图，若图中存在环路则有死锁
    - 死锁恢复：选择一个撤销代价最小的死锁事务进行撤销
  - 事务调度
    - 可串行化调度：事务的并行执行结果与按某个次序串行执行的结果相同
      - 多个事务的并发执行的结果正确，当且仅当这些事务可串行化调度
  - 两段锁协议：若所有事务遵循两段锁协议，则事务的任何并行调度都可串行化
    - 对数据进行读写操作前，必须先获得对数据的封锁
    - 在释放一个封锁后，事务不得获得其他封锁
      即：加锁操作必须在所有解锁操作之前
  - 多粒度封锁：系统同时支持多种封锁粒度，如元组、属性、关系、整个数据库
    - 多粒度树：根结点是数据库，表示最大的粒度；叶结点表示最小的粒度（元组），多粒度封锁协议允许多粒度树的每个结点被独立加锁
      - 在多粒度树上，若一个结点被显式加锁，则其所有后代结点被隐式加类型相同的锁
    - 意向锁：在对一个结点加锁之前，必须对其上层结点加相应的意向锁，这是因为加锁时需要检查是否有隐式封锁冲突
      - 意向共享（IS）锁：表示将对后代结点加S锁
      - 意向排它（IX）锁：表示将对后代结点加X锁
      - 意向共享排它（SIX）锁：表示对该结点同时加S锁和IX锁
    - 锁的共存性
      - IS锁和除X锁外的所有锁共存
      - S锁和IS锁、S锁共存
      - IX锁和IS锁、IX锁共存
      - SIX锁和IS锁共存
      - X锁和任意锁不共存
      - 即：S、IX锁和IS锁与自身共存；SIX锁仅与IS锁共存；X锁不共存

- 分布式数据库

  - 分布式数据库特点：分布性、逻辑整体性

  - 分布式数据库系统的特性：

    - 数据独立性：在逻辑独立性和物理独立性外，还包括分布独立性（分布透明性），即用户不需要关心数据位置分布的细节
    - 集中和自治相结合的控制机构
    - 数据冗余适当增加
    - 全局一致性、可串行性、可恢复性

  - 分布式数据库系统组成部分

    - LDBMS（局部DBMS）
    - GDBMS（全局DBMS）
    - 全局数据字典：包括全局概念模式、分片模式、分布模式等
    - 通信管理

  - 分布独立（透明）性：

    - 分片透明性：用户和应用程序不需要考虑关系的分片
    - 位置透明性：用户和应用程序不需要考虑片段的存储位置
    - 局部数据模型透明性：用户和应用程序不需要了解局部数据模型

  - 数据存储方式

    - 重复存储：两个以上结点维护关系R的完全相同的副本
      - 重复存储可增加系统的可用性、查询并行性
      - 重复存储增加更新操作开销，增加并行控制难度
    - 分片存储：关系的每个片段分别存储在不同结点上
      分片需要遵循的原则：
      - 完全性：关系的每个元组必须属于一个片段
      - 不相交性：同一个关系的片段互不相交
      - 可重构性：可通过片段恢复整个关系
    - 分片方式：
      - 水平分片：以自身的分类条件，按元组分为不相交的子集
      - 垂直分片：按属性分为不相交的子集
      - 导出分片：以其他关系的分类条件，按元组分为不相交的子集
      - 混合分片：在按某种方式分片后，再按另一种方式分片
    - 组合存储：将重复存储和分片存储结合，划分的每个片段都有若干副本

  - 分布式查询

    - 分布式查询类别
      - 局部查询：查询本地结点的数据
      - 远程查询：查询远程单个结点的数据
      - 全局查询：查询多个结点的数据
    - 查询过程
      - 查询变换：将查询转换为析取范式或合取范式
      - 数据定位：将全局查询转换为局部查询
      - 全局查询优化：选择执行操作顺序，降低网络通信开销
        - 全局查询是分布式数据库系统的主要优化对象
      - 局部查询优化
    - 半连接：在自然连接基础上，仅保留其中一个表的数据
      - 半连接在分布式数据库中用于筛选数据，减小通信开销

  - 事务处理

    - 事务管理器（TM）：管理访问局部结点数据的事务
    - 事务协调器（TC）：协调事务，将全局事务分解为若干子事务
      - 一个全局事务的每个子事务要么全部执行，要么全部终止
    - 每个结点都拥有事务管理器和事务协调器

    - 事务提交的两阶段协议：
      - 第一阶段：确认每个结点能够写入
        - 对于事务T，结点S的协调器TC向日志加入\<prepare T>并强制写入日志
        - 将\<prepare T>发送到执行T的所有结点
        - 每个结点的事务管理器TM进行回答，若不提交，将\<no T>写入日志并回答\<abort T>；否则写入\<ready T>并发送\<ready T>
      - 第二阶段：
        - 若结点S的事务协调器TC收到的都是\<ready T>，则事务可以提交，向日志中写入\<commit T>，并向所有结点发送\<commit T>
        - 否则，向日志中写入\<abort T>并发送\<abort T>
        - 每个结点收到消息后，向TC发送\<acknowledge T>，TC收到后将\<complete T>加入日志

  - 分布式并发控制

    - 分布式锁：每个结点拥有一个局部锁管理器，每次事务对局部锁管理器发出加锁请求
      - 死锁处理较复杂
    - 集中式锁：只有一个结点有锁管理器，所有加锁和释放锁都在该结点上处理
      - 死锁处理简单，但容易出现性能瓶颈，且一旦该结点出现故障，则整个系统无法运行
    - 混合锁：设置多个锁管理器，每个锁管理器管理一组数据的加锁和释放锁请求
    - 以多为主的锁协议：每个结点上都有一个锁管理器，结点的锁管理器管理存储在结点上的数据的**所有副本**的加锁和释放锁
      - 如果n个结点存储数据的副本，则加锁时要向n/2以上的存储副本的结点发出加锁请求
    - 区分锁类型的锁协议：每个结点上都有一个锁管理器，每个锁管理器管理结点上存储的数据的加锁和释放锁
      - 共享锁的请求可直接**向访问的结点**的锁管理器发出
      - 排它锁的请求需要**向所有包含数据副本的结点**的锁管理器发出
    - 主副本锁协议：对于具有多个副本的数据，选择其中一个结点的副本作为主副本，该结点作为主结点
      - 在有事务对数据请求加锁时，只向主结点发出加锁请求
      - 当主结点不可用时，数据的其他副本也不可用

  - 死锁处理

    - 集中式方法：使用一个结点作为死锁检测器，存放全局等待图，在死锁检测器被触发时，若发现环路，则通知所有结点放弃某个事务
      - 全局等待图在局部等待图加入或删除边，或协调器需要触发死锁检测时改变
    - 分布式方法：每个结点根据系统行为构造一个全局等待图的子图，满足当死锁存在时至少一个子等待图中出现环路
      - 局部等待图中使用一个特殊结点T$\rm_{ex}$表示外部结点的事务
      - 若局部等待图出现了不包含T$\rm_{ex}$的环，说明出现死锁
      - 若局部等待图出现了包含T$\rm_{ex}$的环，则需要对T$\rm_{ex}$对应的结点发送死锁检测信息，该结点对自己的局部等待图按照收到的信息进行修改后，再次检测是否存在死锁
